"use strict";

var filter = require("reducers/filter")
var map = require("reducers/map")
var hub = require("reducers/hub")
var merge = require("reducers/merge")

var has = require("oops/has")
var field = require("oops/field")
var dictionary = require("oops/dictionary")

var keys = Object.keys


function unit(mapping) {
  /**
  Takes mapping of JSON paths for a state snapshot and `reactor`-or functions
  (typically created via `unit` or `component`) to which state updates scoped
  to that attribute are forwarded. In return `outputs` of state changes caused
  by interactions to an enclosed entities is returned. The role of units is
  to structure components of the application in a logical units that map a
  state model.

  ## Example

      var reactor = unit({
        items: component(reactor(itemWriter, itemReader)),
        count: component(reactor(itemCountWriter))
      })
  **/
  return function reactor(input, options) {
    /**
    Reactor function takes `input` in form of state changes for the unit it
    bound to and returns `output` of state changes caused by interactions
    on that unit. Reactor distributes changes across nested reactors.
    If this reactor is not given an `input` it will assume to be a top level
    reactor and will feed of it's own `output` as all the state changes are
    caused by it.

    Note that reactor is lazy, it will not reactions until `output` returned
    by it is reduced.
    **/

    var outputs = map(keys(mapping), function forkEntityInput(id) {
      // Filter input for a changes on the attribute with a given `id`.
      var inputOnAttribute = filter(input, has(id))
      // Map input for the attribute to an actual `data` for it.
      var attributeInput = map(inputOnAttribute, field(id))

      // There may be several reactors per attribute, invoke each reactor
      // with attribute input and combine outputs of all reactors. Note
      // that since reducers handle objects as single element sequences
      // it's fine if attribute is just a reactor.
      var attributeOutputs = map(mapping[id], function (react) {
        // Get an output from each reactor and reconstruct structure
        // of inputs by mapping output to an `id` of the attribute.
        var attributeOutput = react(attributeInput, options)
        return map(attributeOutput, dictionary(id))
      })

      // Merged all attribute outputs into single form.
      return merge(attributeOutputs)
    })

    // Merge all outputs and multiplex so that all the consumers down
    // the flow would share outputs from this point on.
    var output = hub(merge(outputs))

    // If input is not given then this is a root - an application unit
    // there for all the input is generated by itself. Also note that
    // since all the transformations are lazy `outputs` above is only
    // calculated on first reduction of `output` there for access to
    // `input` will be correct one.
    if (!input) input = output

    return output
  }
}

module.exports = unit
